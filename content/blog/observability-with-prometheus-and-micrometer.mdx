---
title: "Observability with Prometheus and Micrometer"
description: "How to instrument backend services with Micrometer and Prometheus to understand system behavior, detect failures early, and operate reliably in production."
date: "2025-11-25"
---

Observability is often confused with monitoring.

Monitoring tells you **that** something is wrong.  
Observability helps you understand **why** it is wrong.

In production systems, especially distributed ones, this difference matters.

---

## Why Logs Alone Are Not Enough

Logs are useful, but they have limitations:

- They are unstructured by default
- They are hard to aggregate
- They do not provide a global view
- They are reactive, not predictive

When systems scale horizontally, logs alone stop being sufficient.

Metrics become the primary signal.

---

## Prometheus as a Metrics Backbone

Prometheus is built around a simple idea:

> **Collect numeric time-series data and make it queryable.**

It excels at:
- Measuring system behavior over time
- Detecting trends and anomalies
- Alerting before users notice failures

Prometheus does not replace logs or traces â€” it complements them.

---

## Micrometer: Instrumentation for JVM Applications

Micrometer is a metrics facade for JVM-based applications.

It allows you to:
- Instrument code once
- Export metrics to multiple backends
- Standardize naming and labels

In Spring Boot applications, Micrometer is the de facto standard.

---

## Basic Micrometer Setup

Add dependencies:

```xml
<dependency>
  <groupId>io.micrometer</groupId>
  <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

Expose the metrics endpoint:

```properties
management.endpoints.web.exposure.include=health,info,prometheus
```

Prometheus scrapes:

```
/actuator/prometheus
```

---

## Core Metrics You Should Always Have

### Request Metrics

- Request count
- Latency (percentiles)
- Error rate

Example:

```java
Timer.builder("http.server.requests")
  .tag("method", "POST")
  .tag("endpoint", "/orders")
  .register(meterRegistry);
```

---

### JVM Metrics

Micrometer provides these out of the box:

- Heap usage
- GC pauses
- Thread count
- CPU usage

These metrics explain performance issues better than logs.

---

## Custom Business Metrics

Infrastructure metrics are not enough.

You should measure **business-relevant signals**.

Examples:
- Orders created per minute
- Payments processed
- Events published
- Outbox backlog size

```java
Gauge.builder("outbox.pending.events", outboxRepository::countPending)
  .register(meterRegistry);
```

This connects system health to business impact.

---

## Labels and Cardinality

Labels are powerful but dangerous.

Good labels:
- HTTP method
- Status code
- Service name

Bad labels:
- User ID
- Order ID
- Random values

High cardinality leads to:
- Memory pressure
- Slow queries
- Unstable Prometheus servers

Design labels carefully.

---

## Alerting: From Metrics to Action

Alerts should be:
- Actionable
- Rare
- Meaningful

Bad alert:
> CPU usage above 80%

Better alert:
> Error rate above 2% for 5 minutes

Alerts should reflect **user impact**, not raw resource usage.

---

## Observability as a Design Concern

Observability is not an afterthought.

Well-designed systems:
- Expose internal state
- Make failure visible
- Enable safe operations

If you cannot observe a system, you cannot operate it confidently.

---

## Final Thoughts

Prometheus and Micrometer do not make systems reliable.

They make systems **understandable**.

Reliability emerges when:
- Behavior is visible
- Trends are known
- Failures are detected early

Observability turns production from a black box into an engineering discipline.

